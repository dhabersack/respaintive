// Generated by CoffeeScript 1.6.2
(function() {
  var ContextState, Move, MoveHistory, Point, canvas, clearCanvas, color, colors, context, contextState, currentMove, defaultLineCap, defaultLineJoin, defaultLineWidth, defaultStrokeStyle, disableRedo, disableUndo, draw, drawLineTo, enableRedo, enableUndo, executeRedo, executeUndo, executeUndoAll, getEventX, getEventY, initializeColor, initializeTool, isDrawing, redo, redoCount, redoHistory, selectColor, selectTool, setElementColor, startDrawing, stopDrawing, tool, tools, undo, undoAll, undoCount, undoHistory, updateCounts, updateRedoCount, updateUndoCount, _i, _j, _len, _len1;

  ContextState = (function() {
    function ContextState() {}

    ContextState.prototype.restore = function() {
      context.lineWidth = this.lineWidth;
      return context.strokeStyle = this.strokeStyle;
    };

    ContextState.prototype.save = function() {
      this.lineWidth = context.lineWidth;
      return this.strokeStyle = context.strokeStyle;
    };

    return ContextState;

  })();

  MoveHistory = (function() {
    function MoveHistory() {
      this.moves = [];
    }

    MoveHistory.prototype.clear = function() {
      return this.moves.length = 0;
    };

    MoveHistory.prototype.isEmpty = function() {
      return this.moves.length === 0;
    };

    MoveHistory.prototype.pop = function() {
      return this.moves.pop();
    };

    MoveHistory.prototype.push = function(move) {
      return this.moves.push(move);
    };

    MoveHistory.prototype.size = function() {
      return this.moves.length;
    };

    return MoveHistory;

  })();

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Move = (function() {
    function Move(startingPoint, lineWidth, strokeStyle) {
      this.startingPoint = startingPoint;
      this.lineWidth = lineWidth;
      this.strokeStyle = strokeStyle;
      this.points = [];
    }

    Move.prototype.addPoint = function(point) {
      return this.points.push(point);
    };

    Move.prototype.draw = function() {
      var point, _i, _len, _ref;

      context.beginPath();
      context.strokeStyle = this.strokeStyle;
      context.lineWidth = this.lineWidth;
      context.moveTo(this.startingPoint.x, this.startingPoint.y);
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        drawLineTo(point);
      }
      return context.closePath();
    };

    return Move;

  })();

  canvas = document.querySelector('canvas');

  colors = document.querySelectorAll('#colors > li');

  redo = document.getElementById('redo');

  redoCount = document.querySelector('#redo > span');

  tools = document.querySelectorAll('#tools > li');

  undo = document.getElementById('undo');

  undoAll = document.getElementById('undo-all');

  undoCount = document.querySelector('#undo > span');

  defaultStrokeStyle = '#3e3e3e';

  defaultLineCap = 'round';

  defaultLineJoin = 'round';

  defaultLineWidth = 1;

  context = canvas.getContext('2d');

  contextState = new ContextState();

  isDrawing = false;

  currentMove = null;

  redoHistory = new MoveHistory();

  undoHistory = new MoveHistory();

  getEventX = function(event) {
    var x;

    x = event.offsetX ? event.offsetX : event.layerX - canvas.offsetLeft;
    if (event.touches) {
      return event.touches[0].clientX - canvas.offsetLeft;
    } else {
      return x;
    }
  };

  getEventY = function(event) {
    var y;

    y = event.offsetY ? event.offsetY : event.layerY - canvas.offsetTop;
    if (event.touches) {
      return event.touches[0].clientY - canvas.offsetTop;
    } else {
      return y;
    }
  };

  drawLineTo = function(point) {
    context.lineTo(point.x, point.y);
    return context.stroke();
  };

  startDrawing = function(event) {
    var x, y;

    context.beginPath();
    x = getEventX(event);
    y = getEventY(event);
    currentMove = new Move(new Point(x, y), context.lineWidth, context.strokeStyle);
    context.moveTo(x, y);
    return isDrawing = true;
  };

  draw = function(event) {
    var x, y;

    if (isDrawing) {
      x = getEventX(event);
      y = getEventY(event);
      drawLineTo(new Point(x, y));
      currentMove.addPoint(new Point(x, y));
    }
    return event.preventDefault();
  };

  stopDrawing = function(event) {
    context.closePath();
    undoHistory.push(currentMove);
    enableUndo();
    redoHistory.clear();
    disableRedo();
    updateCounts();
    return isDrawing = false;
  };

  initializeColor = function(color) {
    color.addEventListener('click', selectColor, false);
    return setElementColor(color);
  };

  selectColor = function(event) {
    var color, _i, _len;

    context.strokeStyle = event.target.dataset['color'];
    for (_i = 0, _len = colors.length; _i < _len; _i++) {
      color = colors[_i];
      color.className = '';
    }
    return event.target.className = 'active';
  };

  setElementColor = function(element) {
    return element.style.background = element.dataset['color'];
  };

  initializeTool = function(tool) {
    return tool.addEventListener('click', selectTool, false);
  };

  selectTool = function(event) {
    var tool, _i, _len;

    context.lineWidth = event.target.dataset['linewidth'];
    for (_i = 0, _len = tools.length; _i < _len; _i++) {
      tool = tools[_i];
      tool.className = '';
    }
    return event.target.className = 'active';
  };

  executeRedo = function() {
    var move;

    move = redoHistory.pop();
    if (move) {
      contextState.save();
      move.draw();
      undoHistory.push(move);
      updateCounts();
      enableUndo();
      if (redoHistory.isEmpty()) {
        disableRedo();
      }
      return contextState.restore();
    }
  };

  executeUndo = function() {
    var move, _i, _len, _ref;

    clearCanvas();
    contextState.save();
    redoHistory.push(undoHistory.pop());
    _ref = undoHistory.moves;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      move = _ref[_i];
      move.draw();
    }
    updateCounts();
    if (undoHistory.isEmpty()) {
      disableUndo();
    }
    enableRedo();
    return contextState.restore();
  };

  executeUndoAll = function() {
    var move, _i, _len, _ref, _results;

    _ref = undoHistory.moves;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      move = _ref[_i];
      _results.push(executeUndo());
    }
    return _results;
  };

  enableRedo = function() {
    return redo.className = 'available';
  };

  enableUndo = function() {
    undo.className = 'available';
    return undoAll.className = 'available';
  };

  disableRedo = function() {
    return redo.className = '';
  };

  disableUndo = function() {
    undo.className = '';
    return undoAll.className = '';
  };

  updateRedoCount = function() {
    return redoCount.innerHTML = redoHistory.size();
  };

  updateUndoCount = function() {
    return undoCount.innerHTML = undoHistory.size();
  };

  updateCounts = function() {
    updateUndoCount();
    return updateRedoCount();
  };

  clearCanvas = function() {
    return context.clearRect(0, 0, canvas.width, canvas.height);
  };

  context.strokeStyle = defaultStrokeStyle;

  context.lineCap = defaultLineCap;

  context.lineJoin = defaultLineJoin;

  context.lineWidth = defaultLineWidth;

  for (_i = 0, _len = colors.length; _i < _len; _i++) {
    color = colors[_i];
    initializeColor(color);
  }

  for (_j = 0, _len1 = tools.length; _j < _len1; _j++) {
    tool = tools[_j];
    initializeTool(tool);
  }

  canvas.addEventListener('mousedown', startDrawing, false);

  canvas.addEventListener('touchstart', startDrawing, false);

  canvas.addEventListener('mousemove', draw, false);

  canvas.addEventListener('touchmove', draw, false);

  canvas.addEventListener('mouseup', stopDrawing, false);

  canvas.addEventListener('touchend', stopDrawing, false);

  redo.addEventListener('click', executeRedo, false);

  undo.addEventListener('click', executeUndo, false);

  undoAll.addEventListener('click', executeUndoAll, false);

}).call(this);
