// Generated by CoffeeScript 1.6.2
(function() {
  var addCoordinatesToCurrentMove, allMoves, canvas, clearCanvas, colors, context, currentMove, disableUndo, draw, drawLineTo, enableUndo, executeRedo, executeUndo, executeUndoAll, getX, getY, initializeColor, initializeColors, initializeContext, initializeCurrentMove, initializeTool, initializeTools, isDrawing, redo, redoCount, repeatMove, selectColor, selectTool, setElementColor, startDrawing, stopDrawing, tools, undo, undoAll, undoCount, undoneMoves, updateRedoCount, updateUndoCount;

  canvas = document.querySelector('canvas');

  colors = document.querySelectorAll('#colors > li');

  tools = document.querySelectorAll('#tools > li');

  redo = document.getElementById('redo');

  redoCount = document.querySelector('#redo > span');

  undo = document.getElementById('undo');

  undoCount = document.querySelector('#undo > span');

  undoAll = document.getElementById('undo-all');

  context = canvas.getContext('2d');

  isDrawing = false;

  allMoves = [];

  currentMove = null;

  undoneMoves = [];

  getX = function(event) {
    var x;

    x = event.offsetX;
    if (!x) {
      x = event.layerX - canvas.offsetLeft;
    }
    return x;
  };

  getY = function(event) {
    var y;

    y = event.offsetY;
    if (!y) {
      y = event.layerY - canvas.offsetTop;
    }
    return y;
  };

  drawLineTo = function(x, y) {
    context.lineTo(x, y);
    return context.stroke();
  };

  startDrawing = function(event) {
    var x, y;

    isDrawing = true;
    context.beginPath();
    x = getX(event);
    y = getY(event);
    context.moveTo(x, y);
    return initializeCurrentMove(x, y);
  };

  draw = function(event) {
    var x, y;

    if (isDrawing) {
      x = getX(event);
      y = getY(event);
      drawLineTo(x, y);
      return addCoordinatesToCurrentMove(x, y);
    }
  };

  stopDrawing = function(event) {
    context.closePath();
    allMoves.push(currentMove);
    updateUndoCount();
    undoneMoves = [];
    updateRedoCount();
    redo.className = '';
    enableUndo();
    return isDrawing = false;
  };

  initializeColor = function(color) {
    color.addEventListener('click', selectColor);
    return setElementColor(color);
  };

  selectColor = function(event) {
    var color, _i, _len;

    context.strokeStyle = event.target.dataset['color'];
    for (_i = 0, _len = colors.length; _i < _len; _i++) {
      color = colors[_i];
      color.className = '';
    }
    return event.target.className = 'active';
  };

  setElementColor = function(element) {
    return element.style.background = element.dataset['color'];
  };

  initializeTool = function(tool) {
    return tool.addEventListener('click', selectTool);
  };

  selectTool = function(event) {
    var tool, _i, _len;

    context.lineWidth = event.target.dataset['linewidth'];
    for (_i = 0, _len = tools.length; _i < _len; _i++) {
      tool = tools[_i];
      tool.className = '';
    }
    return event.target.className = 'active';
  };

  initializeCurrentMove = function(x, y) {
    return currentMove = {
      lineWidth: context.lineWidth,
      startingPoint: {
        x: x,
        y: y
      },
      strokeStyle: context.strokeStyle,
      points: []
    };
  };

  addCoordinatesToCurrentMove = function(x, y) {
    return currentMove.points.push({
      x: x,
      y: y
    });
  };

  executeUndo = function() {
    var lineWidth, move, strokeStyle, _i, _len;

    clearCanvas();
    lineWidth = context.lineWidth;
    strokeStyle = context.strokeStyle;
    undoneMoves.push(allMoves.pop());
    updateUndoCount();
    updateRedoCount();
    for (_i = 0, _len = allMoves.length; _i < _len; _i++) {
      move = allMoves[_i];
      repeatMove(move);
    }
    context.lineWidth = lineWidth;
    context.strokeStyle = strokeStyle;
    if (allMoves.length === 0) {
      disableUndo();
    }
    return redo.className = 'available';
  };

  enableUndo = function() {
    undo.className = 'available';
    return undoAll.className = 'available';
  };

  disableUndo = function() {
    undo.className = '';
    return undoAll.className = '';
  };

  executeRedo = function() {
    var lineWidth, strokeStyle, undoneMove;

    undoneMove = undoneMoves.pop();
    if (undoneMove) {
      lineWidth = context.lineWidth;
      strokeStyle = context.strokeStyle;
      repeatMove(undoneMove);
      allMoves.push(undoneMove);
      updateUndoCount();
      updateRedoCount();
      enableUndo();
      if (undoneMoves.length === 0) {
        redo.className = '';
      }
      context.lineWidth = lineWidth;
      return context.strokeStyle = strokeStyle;
    }
  };

  updateRedoCount = function() {
    return redoCount.innerHTML = undoneMoves.length;
  };

  updateUndoCount = function() {
    return undoCount.innerHTML = allMoves.length;
  };

  executeUndoAll = function() {
    var move, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = allMoves.length; _i < _len; _i++) {
      move = allMoves[_i];
      _results.push(executeUndo());
    }
    return _results;
  };

  repeatMove = function(move) {
    var firstMove, point, _i, _len, _ref;

    context.beginPath();
    context.strokeStyle = move.strokeStyle;
    context.lineWidth = move.lineWidth;
    firstMove = move.startingPoint;
    context.moveTo(firstMove.x, firstMove.y);
    _ref = move.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      drawLineTo(point.x, point.y);
    }
    return context.closePath();
  };

  clearCanvas = function() {
    return context.clearRect(0, 0, canvas.width, canvas.height);
  };

  initializeContext = function() {
    context.strokeStyle = '#3e3e3e';
    context.lineCap = 'round';
    context.lineJoin = 'round';
    return context.lineWidth = 1;
  };

  initializeColors = function() {
    var color, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = colors.length; _i < _len; _i++) {
      color = colors[_i];
      _results.push(initializeColor(color));
    }
    return _results;
  };

  initializeTools = function() {
    var tool, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = tools.length; _i < _len; _i++) {
      tool = tools[_i];
      _results.push(initializeTool(tool));
    }
    return _results;
  };

  initializeContext();

  initializeColors();

  initializeTools();

  canvas.addEventListener('mousedown', startDrawing, false);

  canvas.addEventListener('mousemove', draw, false);

  canvas.addEventListener('mouseup', stopDrawing, false);

  redo.addEventListener('click', executeRedo, false);

  undo.addEventListener('click', executeUndo, false);

  undoAll.addEventListener('click', executeUndoAll, false);

}).call(this);
